% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smoothn.R
\name{smoothn}
\alias{smoothn}
\title{Robust spline smoothing for one and higher dimensions data}
\usage{
smoothn(
  x,
  s = "auto",
  weight = array(1, dim(x)),
  tol = 0.001,
  initial_guess = array(0, dim(x)),
  spacing = rep(1, dim(x)[2]),
  robust = TRUE,
  robust_iter = 3L,
  robust_inner_iter = 1000L,
  robust_method = "bisquare"
)
}
\arguments{
\item{x}{Array. A gridded numerical dataset.}

\item{s}{Character/Numeric. A positive numerical value that controls the
degree of smoothing. A greater value will result in a smoother output. If
\code{s = "auto"}, the smoothing parameter will be chosen by minimizing the
generalized cross-validation score (GCV) score.}

\item{weight}{Data frame/Matrix/Array. A weight matrix for smoothing.
It should have the same size as \code{x}. Use equal weights by default.}

\item{tol}{Numeric. A positive tolerance value for determining if the
prediction converges.}

\item{initial_guess}{Data frame/Matrix/Array. Initial prediction for the
iterative process. Use a zero matrix by default. If \code{x} contains any
missing data or the provided weight matrix has unequal weights,
\verb{[initial_guess()]} will be used to compute the initial prediction.}

\item{spacing}{Numeric. A vector of positive numeric values controls the
spacing between points in each dimension. Length of the vector should be the
same as the number of columns of \code{x}. Assume equal spacing in all dimensions
by default.}

\item{robust}{Boolean. Whether robust smoothing should be applied to
minimize or cancel the side effects of high leverage points and outliers.}

\item{robust_iter}{Integer. Number of iterations used in robust smoothing.}

\item{robust_inner_iter}{Integer. The maximum number of iterations allowed for
updating the prediction in one robust iteration.}

\item{robust_method}{Character. Weight function for robust smoothing.
One of "bisquare", "talworth" and "cauchy".}
}
\value{
test
}
\description{
This function implements an algorithm for fast and robust smoothing of data
in one and higher dimensions based on a penalized least squares method.
It utilizes the discrete cosine transform for efficient processing.
The algorithm automatically determines the amount of smoothing required
by minimizing the generalized cross-validation score.
}
\examples{

c("test")

}
